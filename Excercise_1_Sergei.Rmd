---
title: "lab_11"
author: "Sergei"
date: "2023-03-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE}
library(igraph)
library(RColorBrewer)
library(visNetwork)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(tidygraph)
library("ggplot2")
library("GGally")
library(ergm)
```

# Exercise one: Analyzing

an offline and online social networks\*\*

```{r cars}
#datainput
highschool_edge<-read.csv("Highschool_network_edge.csv",header=FALSE)
highschool_att<-read.csv("Highschool_network_att.csv",header = TRUE)
facebook_edge<-read.csv("Facebook_network_edge.csv",header=FALSE)
facebook_att<-read.csv("Facebook_network_att.csv",header = TRUE)
```

```{r}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
                  gender=as.character(highschool_att$Gender),
                  hall=as.character(highschool_att$Hall))

highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
                  to=c(as.character(highschool_edge[,2])))

Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices = highschool_nodes)

co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize))) #use only the largest component for analysis
summary(Highschool)
```

```{r}
#build facebook network
facebook_nodes<-data.frame(name=as.character(facebook_att$NodeID))
facebook_edges<-data.frame(from=c(as.character(facebook_edge[,1])),
                           to=c(as.character(facebook_edge[,2])))
Facebook<-graph_from_data_frame(facebook_edges,directed = FALSE,vertices = facebook_nodes)
summary(Facebook)
```

## Question 1 (3 points):

```{r}
degree_HS <- degree(Highschool, mode = "all") %>% sort(T) 
closeness_HS <- closeness(Highschool, normalized = TRUE) %>% sort(T) 
betweenness_HS <- betweenness(Highschool, directed = FALSE, normalized = TRUE)   %>% sort(T) 
eigen_HS <- eigen_centrality(Highschool)$vector  %>% sort(T) 

centralities_HS <- data.frame(degree_HS, closeness_HS, betweenness_HS, eigen_HS)

degree[1]
betweenness[1]
closeness[1]
eigen[1]
```

```{r}
degree_FB <- degree(Facebook, mode = "all") %>% sort(T) 
closeness_FB <- closeness(Facebook, normalized = TRUE) %>% sort(T) 
betweenness_FB <- betweenness(Facebook, directed = FALSE, normalized = TRUE)   %>% sort(T) 
eigen_FB<- eigen_centrality(Facebook)$vector  %>% sort(T) 

centralities_FB <- data.frame(degree_FB, closeness_FB, betweenness_FB, eigen_FB)
```

```{r pressure, echo=FALSE}
set.seed(100)
Highschool_interactive_layout<-visNetwork(data.frame(id=V(Highschool)$name), highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth =  FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>% 
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

Highschool_interactive_layout  

```

```{r}
set.seed(100)
Facebook_interactive_layout<-visNetwork(data.frame(id=V(Facebook)$name), facebook_edges, main = "Facebook",submain="Can zoom in/out to check the IDs and ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth =  FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>% 
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

Facebook_interactive_layout 
```

## Question 2

```{r, message=F}
ggpairs(centralities_HS, aes(alpha = 0.5), 
        lower = list(continuous = "smooth",  colour = "blue"))+
   labs(title = "Centralities for Highschool data")+
  theme_minimal()

```

```{r, message=F}
ggpairs(centralities_FB, aes(alpha = 0.5), lower = list(continuous = "smooth"))+
  labs(title = "Centralities for Facebook data")+
  theme_minimal()
```

```{r}
ggplot(centralities_HS, aes(degree, closeness)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = T ) +
  # Add R-squared and p-value
  geom_text(x = 10, y = 0.35, 
            label = paste("R-squared = ", round(summary(lm(degree ~ closeness))$r.squared, 3), "\n",
                          "p-value = ", format(summary(lm(degree ~ closeness))$coefficients[2, 4], scientific = TRUE, digits = 2)),
            hjust = 1, vjust = 1)


ggplot(centralities_HS, aes(degree, betweenness)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = T) +
  # Add R-squared and p-value
  geom_text(x = 10, y = 0.15, 
            label = paste("R-squared = ", round(summary(lm(degree ~ betweenness))$r.squared, 3), "\n",
                          "p-value = ", format(summary(lm(degree ~ betweenness))$coefficients[2, 4], scientific = TRUE, digits = 2)),
            hjust = 1, vjust = 1)

ggplot(centralities_HS, aes(degree, eigen)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = T) +
  # Add R-squared and p-value
  geom_text(x = 10, y = 0.15, 
            label = paste("R-squared = ", round(summary(lm(degree ~ betweenness))$r.squared, 3), "\n",
                          "p-value = ", format(summary(lm(degree ~ betweenness))$coefficients[2, 4], scientific = TRUE, digits = 2)),
            hjust = 1, vjust = 1)


```

## Question 3 (5 points):

```{r}
h_distance <- distances(
  Highschool,
  v = V(Highschool),
  to = V(Highschool),
  mode = c("all", "out", "in"),
  weights = NULL) %>% sort(decreasing = T)#Shortest path lengths between every pair of two nodes in the network
```

```{r}
# Creating distances vectors
h_distance = 
  distances(
 Highschool,
 v = V(Highschool),
 to = V(Highschool),
 mode = c("all", "out", "in"),
 weights = NULL) 

fb_distance = 
  distances(
 Facebook,
 v = V(Facebook),
 to = V(Facebook),
 mode = c("all", "out", "in"),
 weights = NULL) 

```

```{r}
dd_facebook<- degree_distribution(Facebook)

# Convert degree distribution to data frame
degree_distribution <- data.frame(degree = seq(1:length(dd_facebook)), 
                                  frequency = dd_facebook)


FB_count <- as.data.frame(table(fb_distance)) 
FB_count$fraction <-  FB_count$Freq /sum(FB_count$Freq) # sum by the number of shortest paths
```

```{r}
probs = c(0.5, 0.9)
quantiles <- quantile(degree_FB, prob=probs) 

# Plot degree distribution using ggplot2
ggplot(degree_distribution, aes(x = degree, y = frequency)) +
  geom_bar(stat = "identity") +
  xlab("Degree") +
  ylab("% of total count")+
  geom_vline(xintercept = quantiles[1], colour="red", linetype="dotdash") +
  geom_vline(xintercept = quantiles[2], colour="red", linetype="dotdash" ) +
  scale_y_continuous(labels = scales::percent)+
  geom_label(aes(x = quantiles[1], y = 0.025, label ="q: 0.5")) +
  geom_label(aes(x = quantiles[2], y = 0.025, label = "q: 0.9 ")) +
  labs(title = "Degree distribution for Facebook")+
  theme_minimal()

quantiles <- quantile(fb_distance, prob=probs) + 2
FB_count %>%
  ggplot(aes(x = fb_distance, y = fraction))+
  geom_bar(stat = "identity") +
  geom_vline(xintercept = quantiles[1] , colour="red", linetype="dotdash") +
  geom_vline(xintercept = quantiles[2] , colour="red", linetype="dotdash" ) +
  geom_label(aes(x = quantiles[1]   , y = 0.025, label ="q: 0.5")) +
  geom_label(aes(x = quantiles[2] , y = 0.025, label = "q: 0.9 ")) +
  scale_y_continuous(labels = scales::percent)+
  xlab("Shortest path length") +
  ylab("% of total count by group")+ 
  labs(title = "Shortest path distribution for Facebook")+
  theme_minimal()
```

```{r}
dd_highschool<- degree_distribution(Highschool)

# Convert degree distribution to data frame
degree_distribution <- data.frame(degree = seq(1:length(dd_highschool)), 
                                  frequency = dd_highschool) 

HS_count <- as.data.frame(table(h_distance)) 
HS_count$fraction <-  HS_count$Freq /sum(HS_count$Freq) # sum by the number of shortest paths
```

```{r}

probs = c(0.5, 0.9)
quantiles <- quantile(degree_HS, prob=probs)

# Plot degree distribution using ggplot2
ggplot(degree_distribution, aes(x = degree, y = frequency)) +
  geom_bar(stat = "identity") +
  xlab("Degree") +
  ylab("% of total count")+
  geom_vline(xintercept = quantiles[1], colour="red", linetype="dotdash")+
  geom_vline(xintercept = quantiles[2], colour="red", linetype="dotdash" )+
  scale_y_continuous(labels = scales::percent)+
  geom_label(aes(x = quantiles[1], y = 0.025, label ="q: 0.5"))+
  geom_label(aes(x = quantiles[2], y = 0.025, label = "q: 0.9 "))+
  labs(title = "Degree distribution for High school")+
  theme_minimal()

quantiles = quantile(h_distance, prob=probs) +2

HS_count %>%
  ggplot(aes(x = h_distance, y = fraction))+
  geom_bar(stat = "identity") +
  geom_vline(xintercept = quantiles[1] , colour="red", linetype="dotdash")+
  geom_vline(xintercept = quantiles[2] , colour="red", linetype="dotdash" )+
  geom_label(aes(x = quantiles[1], y = 0.025, label ="q: 0.5"))+
  geom_label(aes(x = quantiles[2] , y = 0.025, label = "q: 0.9 "))+
  scale_y_continuous(labels = scales::percent)+
  xlab("Shortest path length")+
  ylab("% of total count by group")+ 
  labs(title = "Shortest path distribution for High school")+
  theme_minimal()

```

## Question 4

```{r}

#Codes to visualize the network and calculate subgraph density:
## visualize the network by gender###
library(RColorBrewer)
coul <- brewer.pal(length(unique( V(Highschool)$gender)), "Set2")
my_color <- coul[as.numeric(as.factor(V(Highschool)$gender))]
set.seed(10)
plot(Highschool, vertex.color = my_color,
 vertex.size=5,
 layout=layout_nicely(Highschool),vertex.label=NA,
 main="Highschool network by gender")
legend("bottomleft", legend=levels(as.factor(V(Highschool)$gender)) ,col = coul , bty =
"n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))

```

```{r}
#introduce subgraph by gender, calculate their edge densities
group_gender <- as.factor(unique(V(Highschool)$gender))
sapply(levels(group_gender), function(x) {
 y <- induced_subgraph(Highschool, which(V(Highschool)$gender==x))
 cat(paste0("Density for ", x, " friends is ", edge_density(y), '\n'))
})
par(mfrow = c(1, 3))  
for (i in 1:length(group_gender)) {
  subgraph <- subgraph(Highschool, V(Highschool)$gender == group_gender[i])
  plot(subgraph, vertex.size=5,
 layout=layout_nicely(subgraph),vertex.label=NA, xlab =paste(group_gender[i]) )
}
```

```{r}
#introduce subgraph by gender, calculate their edge densities
group_hall <- as.factor(unique(V(Highschool)$hall))

sapply(levels(group_hall), function(x) {
 y <- induced_subgraph(Highschool, which(V(Highschool)$hall==x))
 cat(paste0("Density for ", x, " friends is ", edge_density(y), '\n'))
})

par(mfrow = c(2, 3))
for (i in 1:length(group_hall)) {
  subgraph <- subgraph(Highschool, V(Highschool)$hall == group_hall[i])
  plot(subgraph, vertex.size=5,
 layout=layout_nicely(subgraph),vertex.label=NA, xlab = paste("Network of", group_hall[i]))
}
```

```{r}

dev.off()
paste0('Density for the whole network is ', edge_density(Highschool))
unknown = induced_subgraph(Highschool, V(Highschool)$gender=='unknown')

Highschool_interactive_layout<-visNetwork(data.frame(id=V(unknown)$name),
                                          highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and
ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth = FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)
Highschool_interactive_layout
```

```{r}
library(network)
library("intergraph")
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices = highschool_nodes)
net_Highschool<-asNetwork(Highschool)
net_Highschool %e% "gender" <- highschool_att$Gender
net_Highschool %v% "hall" <- highschool_att$Hall

model <- ergm(net_Highschool ~ edges + nodematch("gender") + nodematch("hall"))

summary(model)
```

## Question 5

```{r}
#Codes to customize community and calculate modularity:
### customize community by gender ###
genderCommunity<-V(Highschool)$gender
genderCommunity<-replace(genderCommunity, genderCommunity=="female",1)
genderCommunity<-replace(genderCommunity, genderCommunity=="male",2)
genderCommunity<-replace(genderCommunity, genderCommunity=="unknown",3)
genderCommunity<-as.numeric(genderCommunity)

hallCommunity<-V(Highschool)$hall
hallCommunity<-replace(hallCommunity,hallCommunity=="1501",1)
hallCommunity<-replace(hallCommunity,hallCommunity=="1502",2)
hallCommunity<-replace(hallCommunity,hallCommunity=="1503",3)
hallCommunity<-replace(hallCommunity,hallCommunity=="1504",4)
hallCommunity<-replace(hallCommunity,hallCommunity=="1505",5)
hallCommunity<-as.numeric(hallCommunity)

#clustering
gender.clustering <- make_clusters(Highschool, membership=genderCommunity)
hall.clustering <- make_clusters(Highschool, membership=hallCommunity)

#modularity
paste0('gender modularity ', modularity(gender.clustering))
paste0('hall modularity ', modularity(hall.clustering))

### Louvain algorithm ###
Louv<-cluster_louvain(Highschool)
modularity(Louv)

```

```{r}

#Codes to visualize the network and calculate subgraph density:
## visualize the network by gender###
library(RColorBrewer)
coul <- brewer.pal(length(unique( Louv$membership)), "Set2")
my_color <- coul[as.numeric(Louv$membership)]
set.seed(10)
plot(Highschool, vertex.color = my_color,
 vertex.size=5,
 layout=layout_nicely(Highschool), vertex.label=NA,
 main="Highschool network by moduarity")
legend("bottomleft", legend= unique(Louv$membership) ,col = coul , bty =
"n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))

``` 


```{r}

#Codes to visualize the network and calculate subgraph density:
## visualize the network by gender###
library(RColorBrewer)
coul <- brewer.pal(length(unique( V(Highschool)$hall)), "Set2")
my_color <- coul[as.numeric(as.factor(V(Highschool)$hall))]
set.seed(10)
plot(Highschool, vertex.color = my_color,
 vertex.size=5,
 layout=layout_nicely(Highschool),vertex.label=NA,
 main="Highschool network by hall")
  legend("bottomleft", legend=levels(as.factor(V(Highschool)$hall)) ,col = coul , bty =
"n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))

```