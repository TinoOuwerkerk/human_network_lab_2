---
title: "Final code"
author: "Sergei"
date: "2023-04-09"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#call library
library(igraph)
library(RColorBrewer)
library(visNetwork)
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(dplyr)
library("GGally") 

#datainput
highschool_edge<-read.csv("Highschool_network_edge.csv",header=FALSE)
highschool_att<-read.csv("Highschool_network_att.csv",header = TRUE)
facebook_edge<-read.csv("Facebook_network_edge.csv",header=FALSE)
facebook_att<-read.csv("Facebook_network_att.csv",header = TRUE)
```

```{r}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
 gender=as.character(highschool_att$Gender),
 hall=as.character(highschool_att$Hall))
highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
 to=c(as.character(highschool_edge[,2])))
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices =
highschool_nodes)
co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize)))

#use only the largest component for analysis
summary(Highschool)

#build facebook network
facebook_nodes<-data.frame(name=as.character(facebook_att$NodeID))
facebook_edges<-data.frame(from=c(as.character(facebook_edge[,1])),
 to=c(as.character(facebook_edge[,2])))
Facebook<-graph_from_data_frame(facebook_edges,directed = FALSE,vertices = facebook_nodes)
summary(Facebook)
```

```{r, message=FALSE,}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
                  gender=as.character(highschool_att$Gender),
                  hall=as.character(highschool_att$Hall))

highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
                  to=c(as.character(highschool_edge[,2])))

Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices = highschool_nodes)

co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize))) #use only the largest component for analysis
summary(Highschool)
```

## Question 1 (3 points):

```{r}
degree_HS <- degree(Highschool, mode = "all") %>% sort(T) 
closeness_HS <- closeness(Highschool, normalized = TRUE) %>% sort(T) 
betweenness_HS <- betweenness(Highschool, directed = FALSE, normalized = TRUE)   %>% sort(T) 
eigen_HS <- eigen_centrality(Highschool)$vector  %>% sort(T) 

centralities_HS <- data.frame(degree_HS, closeness_HS, betweenness_HS, eigen_HS)

# degree[1]
# betweenness[1]
# closeness[1]
# eigen[1]
```

```{r}
degree_FB <- degree(Facebook, mode = "all") %>% sort(T) 
closeness_FB <- closeness(Facebook, normalized = TRUE) %>% sort(T) 
betweenness_FB <- betweenness(Facebook, directed = FALSE, normalized = TRUE)   %>% sort(T) 
eigen_FB<- eigen_centrality(Facebook)$vector  %>% sort(T) 

centralities_FB <- data.frame(degree_FB, closeness_FB, betweenness_FB, eigen_FB)
```

```{r pressure, echo=FALSE}
set.seed(100)
Highschool_interactive_layout<-visNetwork(data.frame(id=V(Highschool)$name), highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth =  FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>% 
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

Highschool_interactive_layout  

```

## Question 2

```{r, message=F}
ggpairs(centralities_HS, aes(alpha = 0.5), 
        lower = list(continuous = "smooth",  colour = "blue"))+
   labs(title = "Centralities for Highschool data")+
  theme_minimal()

```

```{r, message=F}
ggpairs(centralities_FB, aes(alpha = 0.5), lower = list(continuous = "smooth"))+
  labs(title = "Centralities for Facebook data")+
  theme_minimal()
```

## Question 3 (5 points):

```{r}
h_distance <- distances(
  Highschool,
  v = V(Highschool),
  to = V(Highschool),
  mode = c("all", "out", "in"),
  weights = NULL) %>% sort(decreasing = T)#Shortest path lengths between every pair of two nodes in the network
```

```{r}
# Creating distances vectors
h_distance = 
  distances(
 Highschool,
 v = V(Highschool),
 to = V(Highschool),
 mode = c("all", "out", "in"),
 weights = NULL) 

fb_distance = 
  distances(
 Facebook,
 v = V(Facebook),
 to = V(Facebook),
 mode = c("all", "out", "in"),
 weights = NULL) 

```

```{r}
dd_facebook<- degree_distribution(Facebook)

# Convert degree distribution to data frame
degree_distribution <- data.frame(degree = seq(1:length(dd_facebook)), 
                                  frequency = dd_facebook)


FB_count <- as.data.frame(table(fb_distance)) 
FB_count$fraction <-  FB_count$Freq /sum(FB_count$Freq) # sum by the number of shortest paths
```

```{r}
probs = c(0.5, 0.9)
quantiles <- quantile(degree_FB, prob=probs) 

# Plot degree distribution using ggplot2
ggplot(degree_distribution, aes(x = degree, y = frequency)) +
  geom_bar(stat = "identity") +
  xlab("Degree") +
  ylab("% of total count")+
  geom_vline(xintercept = quantiles[1], colour="red", linetype="dotdash") +
  geom_vline(xintercept = quantiles[2], colour="red", linetype="dotdash" ) +
  scale_y_continuous(labels = scales::percent)+
  geom_label(aes(x = quantiles[1], y = 0.025, label ="q: 0.5")) +
  geom_label(aes(x = quantiles[2], y = 0.025, label = "q: 0.9 ")) +
  labs(title = "Degree distribution for Facebook")+
  theme_minimal()

quantiles <- quantile(fb_distance, prob=probs) + 2
FB_count %>%
  ggplot(aes(x = fb_distance, y = fraction))+
  geom_bar(stat = "identity") +
  geom_vline(xintercept = quantiles[1] , colour="red", linetype="dotdash") +
  geom_vline(xintercept = quantiles[2] , colour="red", linetype="dotdash" ) +
  geom_label(aes(x = quantiles[1]   , y = 0.025, label ="q: 0.5")) +
  geom_label(aes(x = quantiles[2] , y = 0.025, label = "q: 0.9 ")) +
  scale_y_continuous(labels = scales::percent)+
  xlab("Shortest path length") +
  ylab("% of total count by group")+ 
  labs(title = "Shortest path distribution for Facebook")+
  theme_minimal()
```

```{r}
dd_highschool<- degree_distribution(Highschool)

# Convert degree distribution to data frame
degree_distribution <- data.frame(degree = seq(1:length(dd_highschool)), 
                                  frequency = dd_highschool) 

HS_count <- as.data.frame(table(h_distance)) 
HS_count$fraction <-  HS_count$Freq /sum(HS_count$Freq) # sum by the number of shortest paths
```

```{r}

probs = c(0.5, 0.9)
quantiles <- quantile(degree_HS, prob=probs)

# Plot degree distribution using ggplot2
ggplot(degree_distribution, aes(x = degree, y = frequency)) +
  geom_bar(stat = "identity") +
  xlab("Degree") +
  ylab("% of total count")+
  geom_vline(xintercept = quantiles[1], colour="red", linetype="dotdash")+
  geom_vline(xintercept = quantiles[2], colour="red", linetype="dotdash" )+
  scale_y_continuous(labels = scales::percent)+
  geom_label(aes(x = quantiles[1], y = 0.025, label ="q: 0.5"))+
  geom_label(aes(x = quantiles[2], y = 0.025, label = "q: 0.9 "))+
  labs(title = "Degree distribution for High school")+
  theme_minimal()

quantiles = quantile(h_distance, prob=probs) +2

HS_count %>%
  ggplot(aes(x = h_distance, y = fraction))+
  geom_bar(stat = "identity") +
  geom_vline(xintercept = quantiles[1] , colour="red", linetype="dotdash")+
  geom_vline(xintercept = quantiles[2] , colour="red", linetype="dotdash" )+
  geom_label(aes(x = quantiles[1], y = 0.025, label ="q: 0.5"))+
  geom_label(aes(x = quantiles[2] , y = 0.025, label = "q: 0.9 "))+
  scale_y_continuous(labels = scales::percent)+
  xlab("Shortest path length")+
  ylab("% of total count by group")+ 
  labs(title = "Shortest path distribution for High school")+
  theme_minimal()

```

## Question 4

```{r}

#Codes to visualize the network and calculate subgraph density:
## visualize the network by gender###
library(RColorBrewer)
coul <- brewer.pal(length(unique( V(Highschool)$gender)), "Set2")
my_color <- coul[as.numeric(as.factor(V(Highschool)$gender))]
set.seed(10)
plot(Highschool, vertex.color = my_color,
 vertex.size=5,
 layout=layout_nicely(Highschool),vertex.label=NA,
 main="Highschool network by gender")
legend("bottomleft", legend=levels(as.factor(V(Highschool)$gender)) ,col = coul , bty =
"n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))

```

```{r}
#introduce subgraph by gender, calculate their edge densities
group_gender <- as.factor(unique(V(Highschool)$gender))
sapply(levels(group_gender), function(x) {
 y <- induced_subgraph(Highschool, which(V(Highschool)$gender==x))
 cat(paste0("Density for ", x, " friends is ", edge_density(y), '\n'))
})
par(mfrow = c(1, 3))  
for (i in 1:length(group_gender)) {
  subgraph <- subgraph(Highschool, V(Highschool)$gender == group_gender[i])
  plot(subgraph, vertex.size=5,
 layout=layout_nicely(subgraph),vertex.label=NA, xlab =paste(group_gender[i]) )
}
```

```{r}
#introduce subgraph by gender, calculate their edge densities
group_hall <- as.factor(unique(V(Highschool)$hall))

sapply(levels(group_hall), function(x) {
 y <- induced_subgraph(Highschool, which(V(Highschool)$hall==x))
 cat(paste0("Density for ", x, " friends is ", edge_density(y), '\n'))
})

par(mfrow = c(2, 3))
for (i in 1:length(group_hall)) {
  subgraph <- subgraph(Highschool, V(Highschool)$hall == group_hall[i])
  plot(subgraph, vertex.size=5,
 layout=layout_nicely(subgraph),vertex.label=NA, xlab = paste("Network of", group_hall[i]))
}
```

```{r}

dev.off()
paste0('Density for the whole network is ', edge_density(Highschool))
unknown = induced_subgraph(Highschool, V(Highschool)$gender=='unknown')

Highschool_interactive_layout<-visNetwork(data.frame(id=V(unknown)$name),
                                          highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and
ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth = FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)
Highschool_interactive_layout
```

```{r}
library(network)
library("intergraph")
library('ergm')
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices = highschool_nodes)
net_Highschool<-asNetwork(Highschool)
net_Highschool %e% "gender" <- highschool_att$Gender
net_Highschool %v% "hall" <- highschool_att$Hall

model <- ergm(net_Highschool ~ edges + nodematch("gender") + nodematch("hall"))

summary(model)
detach("package:ergm", unload=TRUE)
detach("package:network", unload=TRUE)
```

## Question 5

```{r}
#Codes to customize community and calculate modularity:
### customize community by gender ###
genderCommunity<-V(Highschool)$gender
genderCommunity<-replace(genderCommunity, genderCommunity=="female",1)
genderCommunity<-replace(genderCommunity, genderCommunity=="male",2)
genderCommunity<-replace(genderCommunity, genderCommunity=="unknown",3)
genderCommunity<-as.numeric(genderCommunity)

hallCommunity<-V(Highschool)$hall
hallCommunity<-replace(hallCommunity,hallCommunity=="1501",1)
hallCommunity<-replace(hallCommunity,hallCommunity=="1502",2)
hallCommunity<-replace(hallCommunity,hallCommunity=="1503",3)
hallCommunity<-replace(hallCommunity,hallCommunity=="1504",4)
hallCommunity<-replace(hallCommunity,hallCommunity=="1505",5)
hallCommunity<-as.numeric(hallCommunity)

#clustering
gender.clustering <- make_clusters(Highschool, membership=genderCommunity)
hall.clustering <- make_clusters(Highschool, membership=hallCommunity)

#modularity
paste0('gender modularity ', modularity(gender.clustering))
paste0('hall modularity ', modularity(hall.clustering))

### Louvain algorithm ###
Louv<-cluster_louvain(Highschool)
modularity(Louv)

```

```{r}

#Codes to visualize the network and calculate subgraph density:
## visualize the network by gender###
library(RColorBrewer)
coul <- brewer.pal(length(unique( Louv$membership)), "Set2")
my_color <- coul[as.numeric(Louv$membership)]
set.seed(10)
plot(Highschool, vertex.color = my_color,
 vertex.size=5,
 layout=layout_nicely(Highschool), vertex.label=NA,
 main="Highschool network by moduarity")
legend("bottomleft", legend= unique(Louv$membership) ,col = coul , bty =
"n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))

```

```{r}

#Codes to visualize the network and calculate subgraph density:
## visualize the network by gender###
library(RColorBrewer)
coul <- brewer.pal(length(unique( V(Highschool)$hall)), "Set2")
my_color <- coul[as.numeric(as.factor(V(Highschool)$hall))]
set.seed(10)
plot(Highschool, vertex.color = my_color,
 vertex.size=5,
 layout=layout_nicely(Highschool),vertex.label=NA,
 main="Highschool network by hall")
  legend("bottomleft", legend=levels(as.factor(V(Highschool)$hall)) ,col = coul , bty =
"n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))

```

## Question 6

```{r}
n=40
ER1 <- sample_gnp(n, 0.05, directed = FALSE, loops = FALSE)
ER2 <- sample_gnp(n, 0.1, directed = FALSE, loops = FALSE)
ER3 <- sample_gnp(n, 0.2, directed = FALSE, loops = FALSE)
ER1000 <- sample_gnp(1000, 0.2, directed = FALSE, loops= FALSE)
#use only the largest component for analysis
#plot(ER1, layout = layout.circle(ER1), vertex.label = NA)
#plot(ER2, layout = layout.circle(ER2), vertex.label = NA)
#plot(ER3, layout = layout.circle(ER3), vertex.label = NA)
#plot(ER1000)
transitivity(ER1000)
```

## Question 7

Run the following code and discuss with your group mate how the rewiring probability changes the network structure:

```{r}
Regular<-watts.strogatz.game(dim=1,size=300,nei=6, p=0)
plot(Regular, layout=layout.circle, vertex.label=NA, vertex.size=5, 
main = "Network with zero rewiring probability ")

SW1 <- watts.strogatz.game(dim=1,size=300,nei=6, p=0.001)
plot(SW1, layout=layout.circle, vertex.label=NA, vertex.size=5, 
main= "Network with 0.001 rewiring probability ")

SW2 <-watts.strogatz.game(dim=1,size=300,nei=6, p=0.01)
plot(SW2, layout=layout.circle, vertex.label=NA, vertex.size=5, 
main = "Network with 0.01 rewiring probability ")

SW3 <- watts.strogatz.game(dim=1,size=300,nei=6, p=0.1)
plot(SW3, layout=layout.circle, vertex.label=NA, vertex.size=5, 
main = "Network with 0.1 rewiring probability ")

transitivity(Regular)
average.path.length(Regular)

transitivity(SW1)
average.path.length(SW1)
transitivity(SW2)
average.path.length(SW2)
transitivity(SW3)
average.path.length(SW3)
```

## Question 8

```{r}
shortest_paths <- distances(Regular, v = V(Regular), to = V(Regular))
L0 <- mean(shortest_paths[shortest_paths != Inf])
C0 <- transitivity(Regular)
vecC <- character()
vecL <- character()
vecP <- c(0, 0.00001, 0.00005, 0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0,1, 0.5, 1)
for (val in vecP) {
network<-watts.strogatz.game(dim=1,size=300,nei=6, p=val)
shortest_paths <- distances(network, v = V(network), to = V(network))
L <- (mean(shortest_paths[shortest_paths != Inf]))/L0
C <- transitivity(network)/C0
vecL <- append(vecL, L)
vecC <- append(vecC, C)
}

vecL <- as.double(vecL)
vecC <- as.double(vecC)

data <- data.frame(vecL, vecC, vecP)
# Plot the data
ggplot(data) + 
  geom_point(aes(vecP, vecL)) + 
  geom_point(aes(vecP, vecC), colour='black', shape=0) +
  scale_x_log10() +
  labs(x = 'p', y = 'C and L') +
  geom_rect(mapping=aes(xmin=0.0004, xmax=0.012, ymin=0.3, ymax=1.02), color="red", alpha=0.00001) +
  theme_minimal()
```

## Question 9

```{r}
g0 <- barabasi.game(100, power = 0.5 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

g1 <- barabasi.game(100, power = 1 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

g1_5 <- barabasi.game(100, power = 1.5 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

g2 <- barabasi.game(100, power = 2 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

plot(g0, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,layout = layout_nicely(g0), main = "Scale-free network model, power=0.5")

plot(g1, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,layout = layout_nicely(g1), main = "Scale-free network model, power=1")

plot(g1_5, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,layout = layout_nicely(g1_5), main = "Scale-free network model, power=1.5")

plot(g2, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,layout = layout_nicely(g2), main = "Scale-free network model, power=2")

```

```{r}
library(igraph)
set.seed(100)
random_n <- sample(1:100, 1)
subset_random_05 <- igraph::delete.vertices(g0, V(g0) ==  random_n)
subset_random_15 <- igraph::delete.vertices(g1_5, V(g1_5) ==  random_n)

degree_FB <- degree(subset_random_05, mode = "all") %>% sort(T) 

node_with_max05 <- degree(g0) == max(degree(g0))
node_with_max15 <- max(degree(g1_5))

subset_target_05 <- igraph::delete.vertices(g0, V(g0) == match(max(degree(g0)), degree(g0)))
subset_target_15 <- igraph::delete.vertices(g1_5, V(g1_5) == match(max(degree(g1_5)), degree(g1_5)))


diameter(g0)
diameter(g1_5)

diameter(subset_random_05)
diameter(subset_random_15)

diameter(subset_target_05)
diameter(subset_target_15, unconnected = T)

count_components(subset_random_05)
count_components(subset_random_15)

count_components(subset_target_05)
count_components(subset_target_15)
```

```{r}
plot(subset_random_05, vertex.label= NA, edge.arrow.size=2.9,xlim = c(-1, 1), ylim = c(-1, 1) , vertex.size = 4 ,layout = layout_nicely(subset_random_05), xlab = "Random attack on network model, power=0.5")

plot(subset_random_15, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,xlim = c(-1, 1), ylim = c(-1, 1),layout = layout_nicely(subset_random_15), xlab = "Random attack on network model, power=1.5")

plot(subset_target_05, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,xlim = c(-1, 1), ylim = c(-1, 1),layout = layout_nicely(subset_target_05), xlab = "Target attack on network model, power=0.5")

plot(subset_target_15, vertex.label= NA, edge.arrow.size=2.9, vertex.size = 4 ,xlim = c(-1, 1), ylim = c(-1, 1),layout = layout_nicely(subset_target_15), xlab = "Target attack on network model, power=1.5")

```

# Question 10

```{r, echo=FALSE}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
 gender=as.character(highschool_att$Gender),
 hall=as.character(highschool_att$Hall))
highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
 to=c(as.character(highschool_edge[,2])))
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices =
highschool_nodes)
co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize)))

#use only the largest component for analysis
summary(Highschool)

Highschool_interactive_layout<-visNetwork(data.frame(id=V(Highschool)$name),
                                          highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and
ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth = FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)
Highschool_interactive_layout
print('transitivity:')
transitivity(Highschool)
print('average path length:')
average.path.length(Highschool)
```

```{r}

avg_path_length <- average.path.length(Highschool)
print(paste0('avg path length:', avg_path_length))
candidates <- c()
for (i in 1:nrow((highschool_edges))) {
  # remove an edge
  graph2 <- delete_edges(Highschool, i)
  
  # Calculate the new average path length
  new_avg_path_length <- average.path.length(graph2)
  
  # Check if the new average path length is greater than the current one
  if (new_avg_path_length > avg_path_length*1.0125) {
  # Print out the IDs of the source and target nodes for the edge that was removed
  print(paste('deleted edge:', highschool_edges[i,1], "-", highschool_edges[i,2]))
  print(paste0('new_avg_path_length:' ,new_avg_path_length))
  candidates <- append(candidates, i)  
  }
}

graph <- delete_edges(Highschool, candidates)
average.path.length(graph)
my_subset <- data.frame(
    from = highschool_edges$from[candidates],
    to = highschool_edges$to[candidates])
```

## Question 11

```{r, message=FALSE}
stopifnot(require(data.table))
stopifnot(require(Matrix))
calculate_value <- function(node, each_neighbors,Pprob){
 return(each_neighbors[[node]][ which(runif(length(each_neighbors[[node]]), 0, 1)<=Pprob)])
 #'runif' is a function to generate random number in R
}
#This function:
#1) searches the neighbors of contagious node;
#2) To those who are connected to a contagious node, generates a random number and compare to the
#probability of p, if random number<p, this node will be infected and return the value of 1
IC<-function(node_seed,network,Pprob){

 #prepare input for the 'calculate_value' function#
 adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
 each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
 each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node

 nNode<-vcount(network)
 node_status <- rep.int(0, nNode) #start from a healthy population
 day_infected<-vector()#Total number of infected population
 new_infected <- list() # Record the ID of person getting infected at each time step

 day<-1
 node_status[as.numeric(node_seed)] <- 1 # infected(value=1) health(value=0)
 day_infected[day] <- sum(node_status )
 new_infected[[day]]<-node_seed #The ID of the person infected in Day 1 (Patient Zero)

 #simulate the spread of virus within 4 weeks##
 for (day in c(2:28)){
 ContagiousID<-which(node_status == 1)
 infectedID<-unlist(lapply(ContagiousID,calculate_value,each_neighbors,Pprob))
 newinfectedID<- setdiff(infectedID, which(node_status == 1))

 #Update the node status and other variables
 node_status[newinfectedID] <- 1
 day_infected[day] <- length(newinfectedID)
 new_infected[[day]]<-newinfectedID

 day=day+1
 }
 return(day_infected) #return the number of newly infected people by day
 #return(list(day_infected,new_infected)) #if you want to see the ID of infected ppl in each day,use this command instead
}
```

```{r}
tel = 0
for (i in 0:99){
  tel = tel + IC("5", Highschool, 0.15)
}
as.integer(tel/100)
```

## Question 12

```{r}
li = list()
avg_path_length <- average.path.length(Highschool)
print(paste0('avg path length:', avg_path_length))
for (i in 1:nrow(highschool_edges)) {
  # remove an edge
  graph2 <- delete_edges(Highschool, i)
  
  # Calculate the new average path length
  new_avg_path_length <- average.path.length(graph2)
  
  # Check if the new average path length is greater than the current one
  if (new_avg_path_length > avg_path_length*1.0125) {
    li <- append(li, i)
  # Print out the IDs of the source and target nodes for the edge that was removed
  print(paste('deleted edge:', highschool_edges[i,1], "-", highschool_edges[i,2]))
  print(paste0('new_avg_path_length:', new_avg_path_length))
  }
}
```

```{r}
# Delete edges that reduce average path length
Highschool2 <- delete_edges(Highschool, li)
```

```{r}
# Identify strong ties using k-core algorithm
k_cores <- coreness(Highschool2)

# Extract the nodes that belong to the strongest k-core subgraph
strong_ties <- V(Highschool2)[which(k_cores == max(k_cores))]

# Print the nodes in the stronges
print(strong_ties)

list1 <- list('S20|S112','S112|S1', 'S110|S52', 'S107|S28', 'S64|S58')
Highschool3 <- Highschool2
for (edge in list1){
Highschool3<-delete_edges(Highschool3, edge)
}
```

```{r}
Highschool_interactive_layout2<-visNetwork(data.frame(id=V(Highschool2)$name),
                                          highschool_edges, main = "Highschool2",submain="Can zoom in/out to check the IDs and
ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth = FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)
Highschool_interactive_layout2
```

```{r}
infected <- function(network1, network2, network3, p=0.15){
tel1 = 0
tel2 = 0
tel3 = 0
for (i in 0:99){
  tel1 = tel1 + IC("5", network1, p)
  tel2 = tel2 + IC("5", network2, p)
  tel3 = tel3 + IC("5", network3, p)
}
tel1 = as.integer(tel1/100)
tel2 = as.integer(tel2/100)
tel3 = as.integer(tel3/100)

len <- 1:length(tel1)-1
print(tel1)
print(tel2)
print(tel3)

ggplot() + geom_smooth(aes(len, tel1, color='red')) +
  geom_smooth(aes(len, tel2, color='green')) +
  geom_smooth(aes(len, tel3, color='blue')) +
       scale_color_discrete(labels=c('Highschool', 'Highschool2', 'Highschool3')) +
  xlab('day') + ylab('newly infected')

}
```

```{r}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
 gender=as.character(highschool_att$Gender),
 hall=as.character(highschool_att$Hall))
highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
 to=c(as.character(highschool_edge[,2])))
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices =
highschool_nodes)
co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize)))
```

```{r}
infected(Highschool3, Highschool2, Highschool)
```

## Question 13

```{r}
infected(Highschool3, Highschool2, Highschool, 0.075)
```

```{r}
infected(Highschool3, Highschool2, Highschool, 0.9)
```

```{r}
SIR <- function(network, node_seed = "5", Pprob = 0.15) {
  revocered_list = list()
  # prepare input for the 'calculate_value' function
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # get the neighbour list of each node

  nNode <- vcount(network)
  node_status <- rep.int(0, nNode) # start from a healthy population
  node_status_r <- rep.int(0, nNode) # start from a healthy population
  day_infected <- vector() # Total number of infected population
  day_recovered <- vector() # Total number of recovered population
  new_infected <- list() # Record the ID of person getting infected at each time step
  
  day <- 1
  node_status[as.numeric(node_seed)] <- 1 # recovered(value=2) infected(value=1) susceptible(value=0)
  day_infected[day] <- sum(node_status)
  new_infected[[day]] <- node_seed # The ID of the person infected in Day 1 (Patient Zero)
  # simulate the spread of virus within 4 weeks
  for (day in c(2:28)){
    
    ContagiousID<-which(node_status == 1 & node_status != 2)
    
    # Infect nodes that are connected to infectious nodes
    infectedID <- unlist(lapply(ContagiousID, calculate_value, each_neighbors, Pprob))
    newinfectedID <- setdiff(infectedID, which(node_status == 1))

    # Update node status and other variables
    node_status[newinfectedID] <- 1
    day_infected[day] <- sum(node_status == 1)
    day_recovered[day] <- sum(node_status == 2)
    new_infected[[paste("Day",day)]] <- newinfectedID
    
  }
  return(day_infected) # return the number of newly infected people by day
}

results <- SIR(Highschool)
results
```

## Question 14

```{r}

threshold_model <- function(network, node_seed, threshold, n_day){

  nNode <- vcount(network)
  node_status <- rep.int(0, nNode) # start from a healthy population
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # get the neighbour list of each node
  
  
  day <- 1
  for (seed in node_seed){
    node_status[as.numeric(node_seed)] <- 1 # adopt(value=1) dont adopt(value=0)
  }
    
    for (day in 2:n_day) {
      for (node in 1:nNode) {
        if (node_status[node] == 0) {
          neighbours <- each_neighbors[[node]]
          n_neighbors <- length(neighbours)
          n_adopters <- sum(node_status[neighbours] == 1)
          if(n_adopters > n_neighbors * threshold[node]){
            node_status[node] <- 1
          }
        }
      }
    }
  
  
  return(sum(node_status==1))
}
threshold_model(Highschool, list('59', '63', '91', '92', '99'), highschool_att$Threshold, 10000)

```

```{r}
Highschool_interactive_layout
```

```{r}
stopifnot(require(data.table))
stopifnot(require(Matrix))
calculate_adoptedNei <- function(node, node_status, each_neighbors){
 return(mean(node_status[each_neighbors[[node]]] == 1)) ### to calculate the percentage of adopted
neigbhours
}
ThModel<-function(node_seed,network,threshold){
 #prepare input for the 'calculate_value' function#
 adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
 each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
 each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node

 nNode<-vcount(network)
 node_status <- rep.int(0, nNode)
 neighbour_status<-rep.int(0, nNode) ##percentage of adopted neighbours
 new_infected <- list()
 day_total_infected <- rep(0,28) ### Total number of active people by end of each day


 ### Day 1 ####
 day <- 1
 node_status[as.numeric((node_seed))] <- 1
 new_infected[[day]] <-node_seed
 day_total_infected[day]=sum(node_status == 1)
 ####

 for (day in c(2:28)){
 NotAdopted <- which(node_status == 0)
 Adopted <- which(node_status == 1)

 neighbour_status[NotAdopted] <- unlist(lapply(NotAdopted, calculate_adoptedNei, node_status,each_neighbors))

 new_infected[[day]] <- setdiff(which(neighbour_status > threshold), Adopted)
 node_status[new_infected[[day]]] <- 1 #update the staus to 1 for those newly adopted
 day_total_infected[day] <- sum(node_status)

 day <- day + 1
 }
 #return(day_total_infected)
 return(list(day_total_infected,new_infected))
}
ThModel(list('59', '63', '91', '92', '99'), Highschool, highschool_att$Threshold)
```

## Question 15

```{r}
x <- highschool_att$Threshold
# create a sample dataset
my_list <- c(rep(0, 15), rep(0.1, 5), rep(0.2, 5), 0.3, rep(0.4, 2), rep(0.5, 2), 0.6, 0.7, 0.8, rep(0.9, 4), rep(1, 85))

# plot the empirical distribution
plot(my_list, main="Empirical Distribution")
# plot the uni distribution
plot(sort(x), main="Original Threshold Distribution")
```

```{r}
highschool_att$Emp <- sample(my_list)
threshold_model(Highschool, list('59', '63', '91', '92', '99'), highschool_att$Emp, 28)

#ThModel(list('59', '63', '91', '92', '99'), Highschool, highschool_att$Emp)
```

```{r}
# Run the simulation n times and store the results in a vector
n <- 1000
sum <- replicate(n, threshold_model(Highschool, list('59', '63', '91', '92', '99'), highschool_att$Emp, 28))

# Calculate the mean of the results
mean(sum)
```

## Question 17

```{r, message=F}
stopifnot(require(data.table))
stopifnot(require(Matrix))
calculate_value <- function(node, each_neighbors,Pprob){
 return(each_neighbors[[node]][ which(runif(length(each_neighbors[[node]]), 0, 1)<=Pprob)])
 #'runif' is a function to generate random number in R
}
#This function:
#1) searches the neighbors of contagious node;
#2) To those who are connected to a contagious node, generates a random number and compare to the
#probability of p, if random number<p, this node will be infected and return the value of 1
IC_immunized<-function(node_seed,network,Pprob, immunized = c(), n_days = 28 ){

 #prepare input for the 'calculate_value' function#
 adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
 each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
 each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node

 nNode<-vcount(network)
 node_status <- rep.int(0, nNode) #start from a healthy population
 day_infected<-vector()#Total number of infected population
 new_infected <- list() # Record the ID of person getting infected at each time step
 
 day<-1
 node_status[as.numeric(node_seed)] <- 1 # infected(value=1) health(value=0)
 day_infected[day] <- sum(node_status)
 new_infected[[day]] <- node_seed #The ID of the person infected in Day 1 (Patient Zero)
 infected_number = 0 
 number_day <- c()
 
 #simulate the spread of virus within 4 weeks##
 for (day in c(2:n_days)){
 ContagiousID<-which(node_status == 1)
 infectedID<-unlist(lapply(ContagiousID,calculate_value,each_neighbors,Pprob))
 
 infectedID <- setdiff(infectedID, immunized) 
 
 newinfectedID<- setdiff(infectedID, which(node_status == 1))
 
 #Update the node status and other variables
 node_status[newinfectedID] <- 1
 day_infected[day] <- length(newinfectedID)
 infected_number = infected_number + length(newinfectedID)
 new_infected[[day]]<-newinfectedID
 
 number_day <- append(number_day, infected_number)
 day = day+1
 
 }
 return(day_infected ) #return the number of newly infected people by day
 #return(list(day_infected,new_infected)) #if you want to see the ID of infected ppl in each day,use this command instead
}
```

```{r}
degree_n = (degree(Highschool, mode = "all")) %>% sort(T)
degree_n[1:3]
betweenness_n = (betweenness(Highschool)) %>% sort(T)
betweenness_n[1:3]
```

```{r}
no_immune <- IC_immunized("107", Highschool, 0.1)
degree_immune <- IC_immunized("107", Highschool, 0.1, c(54,20, 110))
betweenness_immune <- IC_immunized("107", Highschool, 0.1, c(37,4, 96 ))

days <- seq(1:28)
immune_df <- data.frame(days= days,
           not_immune = no_immune,
           degree_immuned = degree_immune, 
           betweenness_immuned = betweenness_immune)
data_long <- melt(immune_df, id = "days")

sum(no_immune)
sum(degree_immune)
sum(betweenness_immune)
```

```{r}
final_number <- function(network1, network2, network3, p=0.8){
  sum1 = 0
  sum2= 0
  sum3= 0
  node_number <- paste(sample(1:300, 1))
  for (i in 0:99){
    no_immune <- IC_immunized(node_number, network1, p)
    degree_immune <- IC_immunized(node_number, network2, p, c(54,20, 110))
    betweenness_immune <- IC_immunized(node_number, network3, p, c(37,4, 96 ))
     sum1= sum1 + sum(no_immune)
     sum2= sum2 + sum(degree_immune)
     sum3= sum3 + sum(betweenness_immune)
  }
  sum1 = as.integer(sum1/100)
  sum2 = as.integer(sum2/100)
  sum3 = as.integer(sum3/100)
  len <- 1:length(sum1)-1

  return(c(sum1,sum2,sum3))
}
```

```{r}
infected <- function(network1, network2, network3,network4, p=0.1){
tel1 = 0
tel2 = 0
tel3 = 0
tel4 = 0 

for (i in 0:99){
  tel1 = tel1 + IC_immunized("107", network1, p,c(), 28)
  tel2 = tel2 + IC_immunized("107", network2, p, c(54,20, 110), 28)
  tel3 = tel3 + IC_immunized("107", network3, p, c(37,4, 96 ), 28)
  tel4 = tel4 + IC_immunized("107", network4, p, c(36, 118, 97), 28)

}

tel1 = as.integer(tel1/100)
tel2 = as.integer(tel2/100)
tel3 = as.integer(tel3/100)
tel4 = as.integer(tel4/100)
len <- 1:length(tel1)-1

ggplot() + geom_smooth(aes(len, tel1, colour='No Immunity'), se =F) +
  geom_smooth(aes(len, tel2, colour='Degree heuristic'), se =F) +
  geom_smooth(aes(len, tel3, colour='Betweenness heuristic'), se =F) +
       scale_fill_discrete(labels=c('Highschool', 'Highschool2', 'Highschool3'))+  
  labs(x = "Days", y = "Average Number of infected nodes", title = paste("Average Number of infected nodes in Barabasi model")
        )+
  theme_minimal()
}

```

```{r}
infected(Highschool, Highschool, Highschool, 0.15)
```

```{r}
SW3<-watts.strogatz.game(dim=1,size=300,nei=6, p=0.01)
plot(SW3, layout=layout.circle, vertex.label=NA, vertex.size=5, 
main= "Network with 0.1 rewiring probability ")


g0 <- barabasi.game(300, power = 0.5 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

g1 <- barabasi.game(300, power = 1 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

g1_5 <- barabasi.game(300, power = 1.5 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 

g2 <- barabasi.game(300, power = 2 , m = NULL, out.dist = NULL, out.seq = NULL, out.pref = FALSE, zero.appeal = 1, directed = FALSE,algorithm ="psumtree", start.graph = NULL) 
```

```{r}
infected_random <- function(network1, network2, network3, p=0.8){
tel1 = 0
tel2 = 0
tel3 = 0
node_number <- paste(sample(1:300, 1))
for (i in 0:99){
  tel1 = tel1 + IC_immunized(node_number, network1, p,c(), 40)
  tel2 = tel2 + IC_immunized(node_number, network2, p, c(54,20, 110), 40)
  tel3 = tel3 + IC_immunized(node_number, network3, p, c(37,4, 96 ), 40)

}

tel1 = as.integer(tel1/100)
tel2 = as.integer(tel2/100)
tel3 = as.integer(tel3/100)
len <- 1:length(tel1)-1

ggplot() + geom_smooth(aes(len, tel1, colour='No Immunity'), se =F) +
  geom_smooth(aes(len, tel2, colour='Degree heuristic'), se =F) +
  geom_smooth(aes(len, tel3, colour='Betweenness heuristic'), se =F) +
       scale_fill_discrete(labels=c('Highschool', 'Highschool2', 'Highschool3'))+  
  labs(x = "Days", y = "Average Number of infected nodes", title = paste("Average Number of infected nodes in Barabasi model")
        )+
  theme_minimal()
}c

```

```{r}
c <- c()
for (i in seq(0, 0.5, 0.1)){
  c <-append(c, final_number(SW3,SW3, SW3,p=i))
}
c
```

```{r}
infected_random(SW3, SW3, SW3, 0.06)
```

# Question 18

# Checking the greedy

```{r}
final_number_greedy <- function(node_number, network1, network2, network3, network4, p=0.15){
  sum1 = 0
  sum2 = 0
  sum3 = 0
  sum4 = 0
  # node_number <- paste(sample(1:300, 1))
  for (i in 0:99){
    no_immune <- IC_immunized(node_number, network1, p)
    degree_immune <- IC_immunized(node_number, network2, p, c(54,20, 110))
    betweenness_immune <- IC_immunized(node_number, network3, p, c(37,4, 96 ))
    greedy = IC_immunized(node_number, network4, p, c(37, 21, 9), 28)
     sum1= sum1 + sum(no_immune)
     sum2= sum2 + sum(degree_immune)
     sum3= sum3 + sum(betweenness_immune)
     sum4= sum4 + sum(betweenness_immune)
  }
  sum1 = as.integer(sum1/100)
  sum2 = as.integer(sum2/100)
  sum3 = as.integer(sum3/100)
  sum4 = as.integer(sum4/100)
  len <- 1:length(sum1)-1

  return(c(sum1,sum2,sum3, sum4))
}
```

```{r}
infected_greedy <- function(node_number, network1, network2, network3, network4, p=0.15){
tel1 = 0
tel2 = 0
tel3 = 0
tel4 = 0
# node_number <- paste(sample(1:122, 1))
for (i in 0:100){
  tel1 = tel1 + IC_immunized(node_number, network1, p, c(), 28)
  tel2 = tel2 + IC_immunized(node_number, network2, p, c(54,20, 110), 28)
  tel3 = tel3 + IC_immunized(node_number, network3, p, c(37, 4, 96 ), 28)
  tel4 = tel4 + IC_immunized(node_number, network4, p, c(96, 37, 70), 28)

}

tel1 = as.integer(tel1/100)
tel2 = as.integer(tel2/100)
tel3 = as.integer(tel3/100)
tel4 = as.integer(tel4/100)
len <- 1:length(tel1)-1

ggplot() + geom_smooth(aes(len, tel1, colour='No Immunity'), se =F) +
  geom_smooth(aes(len, tel2, colour='Degree heuristic'), se =F) +
  geom_smooth(aes(len, tel3, colour='Betweenness heuristic'), se =F) +
  geom_smooth(aes(len, tel4, colour='Greedy'), se =F) +
       scale_fill_discrete(labels=c('Highschool', 'Highschool2', 'Highschool3'))+  
  labs(x = "Days", y = "Average Number of infected nodes", title = paste("Average Number of infected nodes of 100 MC simulations in Highschool network")
        )+
  theme_minimal()
}
```

```{r}
final_number_greedy(107, Highschool, Highschool, Highschool, Highschool,p =  0.06)

```

```{r}
infected_greedy(107, Highschool, Highschool, Highschool, Highschool, p =  0.15)
```
