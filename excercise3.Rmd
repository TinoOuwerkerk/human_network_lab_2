---
title: "excercise3"
author: "tino"
date: "2023-03-29"
output: html_document
---

## Libraries

```{r}
#call library
library(igraph)
library(RColorBrewer)
library(visNetwork)
library(ggplot2)
library(tidyverse)
library(ggpubr)
# setwd("C:/Users/tinot/uu/human_network_lab_2")
#datainput
highschool_edge<-read.csv("Highschool_network_edge.csv",header=FALSE)
highschool_att<-read.csv("Highschool_network_att.csv",header = TRUE)
```

## Network

```{r}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
 gender=as.character(highschool_att$Gender),
 hall=as.character(highschool_att$Hall))
highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
 to=c(as.character(highschool_edge[,2])))
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices =
highschool_nodes)
co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize)))

#use only the largest component for analysis
summary(Highschool)

Highschool_interactive_layout<-visNetwork(data.frame(id=V(Highschool)$name),
                                          highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and
ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth = FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

transitivity(Highschool)
print('average path length:')
average.path.length(Highschool)
```

## Question 10

```{r}
li = list()
avg_path_length <- average.path.length(Highschool)
print(paste0('avg path length:', avg_path_length))
for (i in 1:nrow(highschool_edges)) {
  # remove an edge
  graph2 <- delete.edges(Highschool, i)
  
  # Calculate the new average path length
  new_avg_path_length <- average.path.length(graph2)
  
  # Check if the new average path length is greater than the current one
  if (new_avg_path_length > avg_path_length*1.0125) {
    li <- append(li, i)
  # Print out the IDs of the source and target nodes for the edge that was removed
  print(paste('deleted edge:', highschool_edges[i,1], "-", highschool_edges[i,2]))
  print(paste0('new_avg_path_length:', new_avg_path_length))
  }
}
```

## Question 11

```{r}
stopifnot(require(data.table))
stopifnot(require(Matrix))
calculate_value <- function(node, each_neighbors,Pprob){
 return(each_neighbors[[node]][ which(runif(length(each_neighbors[[node]]), 0, 1)<=Pprob)])
 #'runif' is a function to generate random number in R
}
#This function:
#1) searches the neighbors of contagious node;
#2) To those who are connected to a contagious node, generates a random number and compare to the
#probability of p, if random number<p, this node will be infected and return the value of 1
IC<-function(node_seed,network,Pprob){

 #prepare input for the 'calculate_value' function#
 adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
 each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
 each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node

 nNode<-vcount(network)
 node_status <- rep.int(0, nNode) #start from a healthy population
 day_infected<-vector()#Total number of infected population
 new_infected <- list() # Record the ID of person getting infected at each time step

 day<-1
 node_status[as.numeric(node_seed)] <- 1 # infected(value=1) health(value=0)
 day_infected[day] <- sum(node_status )
 new_infected[[day]]<-node_seed #The ID of the person infected in Day 1 (Patient Zero)

 #simulate the spread of virus within 4 weeks##
 for (day in c(2:28)){
 ContagiousID<-which(node_status == 1)
 infectedID<-unlist(lapply(ContagiousID,calculate_value,each_neighbors,Pprob))
 newinfectedID<- setdiff(infectedID, which(node_status == 1))

 #Update the node status and other variables
 node_status[newinfectedID] <- 1
 day_infected[day] <- length(newinfectedID)
 new_infected[[day]]<-newinfectedID

 day=day+1
 }
 return(day_infected) #return the number of newly infected people by day
 #return(list(day_infected,new_infected)) #if you want to see the ID of infected ppl in each day,use this command instead
}
```

```{r}
tel = 0
for (i in 0:99){
  tel = tel + IC("5", Highschool, 0.15)
}
as.integer(tel/100)
```

## Question 12

```{r}
# Delete edges that reduce average path length
Highschool2 <- delete.edges(Highschool, li)
```

```{r}
# Identify strong ties using k-core algorithm
k_cores <- coreness(Highschool2)

# Extract the nodes that belong to the strongest k-core subgraph
strong_ties <- V(Highschool2)[which(k_cores == max(k_cores))]

# Print the nodes in the stronges
print(strong_ties)

list1 <- list('S20|S112','S112|S1', 'S110|S52', 'S107|S28', 'S64|S58')
Highschool3 <- Highschool2
for (edge in list1){
Highschool3<-delete.edges(Highschool3, edge)
}
```

```{r}
Highschool_interactive_layout2<-visNetwork(data.frame(id=V(Highschool2)$name),
                                          highschool_edges, main = "Highschool2",submain="Can zoom in/out to check the IDs and
ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth = FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)
Highschool_interactive_layout2
```

```{r}
infected <- function(network1, network2, network3, p=0.15){
tel1 = 0
tel2 = 0
tel3 = 0
for (i in 0:99){
  tel1 = tel1 + IC("5", network1, p)
  tel2 = tel2 + IC("5", network2, p)
  tel3 = tel3 + IC("5", network3, p)
}
tel1 = as.integer(tel1/100)
tel2 = as.integer(tel2/100)
tel3 = as.integer(tel3/100)

len <- 1:length(tel1)-1
print(tel1)
print(tel2)
print(tel3)

ggplot() + geom_smooth(aes(len, tel1, color='red')) +
  geom_smooth(aes(len, tel2, color='green')) +
  geom_smooth(aes(len, tel3, color='blue')) +
       scale_color_discrete(labels=c('Highschool', 'Highschool2', 'Highschool3')) +
  xlab('day') + ylab('newly infected')

}
```

```{r}
infected(Highschool3, Highschool2, Highschool)
```

## Question 13

```{r}
infected(Highschool3, Highschool2, Highschool, 0.075)
```

```{r}
infected(Highschool3, Highschool2, Highschool, 0.9)
```

```{r}
SIR <- function(network, node_seed = "5", Pprob = 0.15) {
  revocered_list = list()
  # prepare input for the 'calculate_value' function
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # get the neighbour list of each node

  nNode <- vcount(network)
  node_status <- rep.int(0, nNode) # start from a healthy population
  node_status_r <- rep.int(0, nNode) # start from a healthy population
  day_infected <- vector() # Total number of infected population
  day_recovered <- vector() # Total number of recovered population
  new_infected <- list() # Record the ID of person getting infected at each time step
  
  day <- 1
  node_status[as.numeric(node_seed)] <- 1 # recovered(value=2) infected(value=1) susceptible(value=0)
  day_infected[day] <- sum(node_status)
  new_infected[[day]] <- node_seed # The ID of the person infected in Day 1 (Patient Zero)
  # simulate the spread of virus within 4 weeks
  for (day in c(2:28)){
    
    ContagiousID<-which(node_status == 1 & node_status != 2)
    
    # Infect nodes that are connected to infectious nodes
    infectedID <- unlist(lapply(ContagiousID, calculate_value, each_neighbors, Pprob))
    newinfectedID <- setdiff(infectedID, which(node_status == 1))

    # Update node status and other variables
    node_status[newinfectedID] <- 1
    day_infected[day] <- sum(node_status == 1)
    day_recovered[day] <- sum(node_status == 2)
    new_infected[[paste("Day",day)]] <- newinfectedID
    
  }
  return(day_infected) # return the number of newly infected people by day
}

results <- SIR(Highschool)
results
```

## Question 14

```{r}

threshold_model <- function(network, node_seed, threshold, n_day){

  nNode <- vcount(network)
  node_status <- rep.int(0, nNode) # start from a healthy population
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # get the neighbour list of each node
  
  
  day <- 1
  for (seed in node_seed){
    node_status[as.numeric(node_seed)] <- 1 # adopt(value=1) dont adopt(value=0)
  }
    
    for (day in 2:n_day) {
      for (node in 1:nNode) {
        if (node_status[node] == 0) {
          neighbours <- each_neighbors[[node]]
          n_neighbors <- length(neighbours)
          n_adopters <- sum(node_status[neighbours] == 1)
          if(n_adopters > n_neighbors * threshold[node]){
            node_status[node] <- 1
          }
        }
      }
    }
  
  
  return(sum(node_status==1))
}
threshold_model(Highschool, list('59', '63', '91', '92', '99'), highschool_att$Threshold, 10000)

```

```{r}
Highschool_interactive_layout
```

```{r}
stopifnot(require(data.table))
stopifnot(require(Matrix))
calculate_adoptedNei <- function(node, node_status, each_neighbors){
 return(mean(node_status[each_neighbors[[node]]] == 1)) ### to calculate the percentage of adopted
neigbhours
}
ThModel<-function(node_seed,network,threshold){
 #prepare input for the 'calculate_value' function#
 adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
 each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
 each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node

 nNode<-vcount(network)
 node_status <- rep.int(0, nNode)
 neighbour_status<-rep.int(0, nNode) ##percentage of adopted neighbours
 new_infected <- list()
 day_total_infected <- rep(0,28) ### Total number of active people by end of each day


 ### Day 1 ####
 day <- 1
 node_status[as.numeric((node_seed))] <- 1
 new_infected[[day]] <-node_seed
 day_total_infected[day]=sum(node_status == 1)
 ####

 for (day in c(2:28)){
 NotAdopted <- which(node_status == 0)
 Adopted <- which(node_status == 1)

 neighbour_status[NotAdopted] <- unlist(lapply(NotAdopted, calculate_adoptedNei, node_status,each_neighbors))

 new_infected[[day]] <- setdiff(which(neighbour_status > threshold), Adopted)
 node_status[new_infected[[day]]] <- 1 #update the staus to 1 for those newly adopted
 day_total_infected[day] <- sum(node_status)

 day <- day + 1
 }
 #return(day_total_infected)
 return(list(day_total_infected,new_infected))
}
ThModel(list('59', '63', '91', '92', '99'), Highschool, highschool_att$Threshold)
```

## Question 15

```{r}
x <- highschool_att$Threshold
# create a sample dataset
  my_list <- c(rep(0, 51), rep(0.1, 18), rep(0.2, 4), rep(0.3, 4), rep(0.4, 8), rep(0.5, 8), rep(0.6, 4), rep(0.7, 4), rep(0.8, 4), rep(0.9, 0), rep(1, 17))

# plot the empirical distribution
plot(my_list, main="Empirical Distribution")
# plot the uni distribution
plot(sort(x), main="Original Threshold Distribution")
```

sample(my_list)

```{r}
highschool_att$Emp <- sample(my_list)
threshold_model(Highschool, list('59', '63', '91', '92', '99'), highschool_att$Emp, 28)

ThModel(list('59', '63', '91', '92', '99'), Highschool, highschool_att$Emp)
```

```{r}
# Run the simulation n times and store the results in a vector
n <- 1000

sum <- replicate(n, threshold_model(Highschool, list('59', '63', '91', '92', '99'), sample(my_list), 28))

# Calculate the mean of the results
mean(sum)
```

## Different students q15

```{r}
ThModel(list('37', '4', '96', '24', '70', '77', '17'), Highschool, highschool_att$Emp)
```

```{r}
ThModel(list('68', '88', '17', '82', '90', '94', '56'), Highschool, highschool_att$Emp)
```

```{r}
ThModel(list('54', '20', '110', '64', '96', '28', '37'), Highschool, highschool_att$Emp)
```
